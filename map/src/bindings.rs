// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod s4 {
    pub mod compression {
        #[allow(dead_code, clippy::all)]
        pub mod decompress {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn decompress(input: &[u8]) -> Result<_rt::Vec<u8>, _rt::String> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let vec0 = input;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "s4:compression/decompress@0.1.0")]
                    extern "C" {
                        #[link_name = "decompress"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1);
                    let l2 = i32::from(*ptr1.add(0).cast::<u8>());
                    match l2 {
                        0 => {
                            let e = {
                                let l3 = *ptr1.add(4).cast::<*mut u8>();
                                let l4 = *ptr1.add(8).cast::<usize>();
                                let len5 = l4;
                                _rt::Vec::from_raw_parts(l3.cast(), len5, len5)
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l6 = *ptr1.add(4).cast::<*mut u8>();
                                let l7 = *ptr1.add(8).cast::<usize>();
                                let len8 = l7;
                                let bytes8 = _rt::Vec::from_raw_parts(
                                    l6.cast(),
                                    len8,
                                    len8,
                                );
                                _rt::string_lift(bytes8)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
        }
    }
    pub mod encryption {
        #[allow(dead_code, clippy::all)]
        pub mod decryption {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn decrypt(input: &[u8]) -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = input;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "s4:encryption/decryption@0.1.0")]
                    extern "C" {
                        #[link_name = "decrypt"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1);
                    let l2 = *ptr1.add(0).cast::<*mut u8>();
                    let l3 = *ptr1.add(4).cast::<usize>();
                    let len4 = l3;
                    _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod s4 {
        pub mod files {
            #[allow(dead_code, clippy::all)]
            pub mod load {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum WareKind {
                    Agave,
                    Ammo,
                    Armor,
                    Axe,
                    BattleAxe,
                    Blowgun,
                    Board,
                    Bow,
                    Bread,
                    Coal,
                    Fish,
                    Flour,
                    Goat,
                    Gold,
                    GoldOre,
                    Grain,
                    Gunpowder,
                    Hammer,
                    Honey,
                    Iron,
                    IronOre,
                    Log,
                    Mead,
                    Meat,
                    Pickaxe,
                    Pig,
                    FishingRod,
                    Saw,
                    Scythe,
                    Sheep,
                    Shovel,
                    Stone,
                    Sulfur,
                    Sword,
                    Tequila,
                    Water,
                    Wine,
                    BackpackCatapult,
                    Goose,
                    ExplosiveArrow,
                    SunflowerOil,
                    Sunflower,
                }
                impl ::core::fmt::Debug for WareKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            WareKind::Agave => f.debug_tuple("WareKind::Agave").finish(),
                            WareKind::Ammo => f.debug_tuple("WareKind::Ammo").finish(),
                            WareKind::Armor => f.debug_tuple("WareKind::Armor").finish(),
                            WareKind::Axe => f.debug_tuple("WareKind::Axe").finish(),
                            WareKind::BattleAxe => {
                                f.debug_tuple("WareKind::BattleAxe").finish()
                            }
                            WareKind::Blowgun => {
                                f.debug_tuple("WareKind::Blowgun").finish()
                            }
                            WareKind::Board => f.debug_tuple("WareKind::Board").finish(),
                            WareKind::Bow => f.debug_tuple("WareKind::Bow").finish(),
                            WareKind::Bread => f.debug_tuple("WareKind::Bread").finish(),
                            WareKind::Coal => f.debug_tuple("WareKind::Coal").finish(),
                            WareKind::Fish => f.debug_tuple("WareKind::Fish").finish(),
                            WareKind::Flour => f.debug_tuple("WareKind::Flour").finish(),
                            WareKind::Goat => f.debug_tuple("WareKind::Goat").finish(),
                            WareKind::Gold => f.debug_tuple("WareKind::Gold").finish(),
                            WareKind::GoldOre => {
                                f.debug_tuple("WareKind::GoldOre").finish()
                            }
                            WareKind::Grain => f.debug_tuple("WareKind::Grain").finish(),
                            WareKind::Gunpowder => {
                                f.debug_tuple("WareKind::Gunpowder").finish()
                            }
                            WareKind::Hammer => {
                                f.debug_tuple("WareKind::Hammer").finish()
                            }
                            WareKind::Honey => f.debug_tuple("WareKind::Honey").finish(),
                            WareKind::Iron => f.debug_tuple("WareKind::Iron").finish(),
                            WareKind::IronOre => {
                                f.debug_tuple("WareKind::IronOre").finish()
                            }
                            WareKind::Log => f.debug_tuple("WareKind::Log").finish(),
                            WareKind::Mead => f.debug_tuple("WareKind::Mead").finish(),
                            WareKind::Meat => f.debug_tuple("WareKind::Meat").finish(),
                            WareKind::Pickaxe => {
                                f.debug_tuple("WareKind::Pickaxe").finish()
                            }
                            WareKind::Pig => f.debug_tuple("WareKind::Pig").finish(),
                            WareKind::FishingRod => {
                                f.debug_tuple("WareKind::FishingRod").finish()
                            }
                            WareKind::Saw => f.debug_tuple("WareKind::Saw").finish(),
                            WareKind::Scythe => {
                                f.debug_tuple("WareKind::Scythe").finish()
                            }
                            WareKind::Sheep => f.debug_tuple("WareKind::Sheep").finish(),
                            WareKind::Shovel => {
                                f.debug_tuple("WareKind::Shovel").finish()
                            }
                            WareKind::Stone => f.debug_tuple("WareKind::Stone").finish(),
                            WareKind::Sulfur => {
                                f.debug_tuple("WareKind::Sulfur").finish()
                            }
                            WareKind::Sword => f.debug_tuple("WareKind::Sword").finish(),
                            WareKind::Tequila => {
                                f.debug_tuple("WareKind::Tequila").finish()
                            }
                            WareKind::Water => f.debug_tuple("WareKind::Water").finish(),
                            WareKind::Wine => f.debug_tuple("WareKind::Wine").finish(),
                            WareKind::BackpackCatapult => {
                                f.debug_tuple("WareKind::BackpackCatapult").finish()
                            }
                            WareKind::Goose => f.debug_tuple("WareKind::Goose").finish(),
                            WareKind::ExplosiveArrow => {
                                f.debug_tuple("WareKind::ExplosiveArrow").finish()
                            }
                            WareKind::SunflowerOil => {
                                f.debug_tuple("WareKind::SunflowerOil").finish()
                            }
                            WareKind::Sunflower => {
                                f.debug_tuple("WareKind::Sunflower").finish()
                            }
                        }
                    }
                }
                impl WareKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> WareKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => WareKind::Agave,
                            1 => WareKind::Ammo,
                            2 => WareKind::Armor,
                            3 => WareKind::Axe,
                            4 => WareKind::BattleAxe,
                            5 => WareKind::Blowgun,
                            6 => WareKind::Board,
                            7 => WareKind::Bow,
                            8 => WareKind::Bread,
                            9 => WareKind::Coal,
                            10 => WareKind::Fish,
                            11 => WareKind::Flour,
                            12 => WareKind::Goat,
                            13 => WareKind::Gold,
                            14 => WareKind::GoldOre,
                            15 => WareKind::Grain,
                            16 => WareKind::Gunpowder,
                            17 => WareKind::Hammer,
                            18 => WareKind::Honey,
                            19 => WareKind::Iron,
                            20 => WareKind::IronOre,
                            21 => WareKind::Log,
                            22 => WareKind::Mead,
                            23 => WareKind::Meat,
                            24 => WareKind::Pickaxe,
                            25 => WareKind::Pig,
                            26 => WareKind::FishingRod,
                            27 => WareKind::Saw,
                            28 => WareKind::Scythe,
                            29 => WareKind::Sheep,
                            30 => WareKind::Shovel,
                            31 => WareKind::Stone,
                            32 => WareKind::Sulfur,
                            33 => WareKind::Sword,
                            34 => WareKind::Tequila,
                            35 => WareKind::Water,
                            36 => WareKind::Wine,
                            37 => WareKind::BackpackCatapult,
                            38 => WareKind::Goose,
                            39 => WareKind::ExplosiveArrow,
                            40 => WareKind::SunflowerOil,
                            41 => WareKind::Sunflower,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct WareStack {
                    pub size: u8,
                    pub kind: WareKind,
                }
                impl ::core::fmt::Debug for WareStack {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("WareStack")
                            .field("size", &self.size)
                            .field("kind", &self.kind)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum SettlerKind {
                    Carrier,
                    Planer,
                    Builder,
                    Woodcutter,
                    Stonecutter,
                    Forester,
                    GrainFarmer,
                    AnimalFarmer,
                    Fisher,
                    Waterworker,
                    Hunter,
                    SawmillWorker,
                    Smelter,
                    Mineworker,
                    Smith,
                    Miller,
                    Baker,
                    Butcher,
                    ShipyardWorker,
                    Healer,
                    CharcoalMaker,
                    AmmoMaker,
                    VehicleMaker,
                    Vinter,
                    Beekeeper,
                    Meadmaker,
                    AgaveFarmer,
                    TequilaMaker,
                    Level1Swordsman,
                    Level2Swordsman,
                    Level3Swordsman,
                    Level1Archer,
                    Level2Archer,
                    Level3Archer,
                    Level1Medic,
                    Level2Medic,
                    Level3Medic,
                    Level1AxeWarrior,
                    Level2AxeWarrior,
                    Level3AxeWarrior,
                    Level1Blowgun,
                    Level2Blowgun,
                    Level3Blowgun,
                    SquadLeader,
                    Priest,
                    Saboteur,
                    Pioneer,
                    Thief,
                    Geologist,
                    Gardener,
                    Landscaper,
                    DarkGardener,
                    MushroomFarmer,
                    Shaman,
                    DarkSettler,
                    TempleServant,
                    Level1Angel,
                    Level2Angel,
                    Level3Angel,
                    Donkey,
                    Level1BackpackCatapultist,
                    Level2BackpackCatapultist,
                    Level3BackpackCatapultist,
                    SunflowerFarmer,
                    SunoilMaker,
                    ManacopterMaster,
                }
                impl ::core::fmt::Debug for SettlerKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            SettlerKind::Carrier => {
                                f.debug_tuple("SettlerKind::Carrier").finish()
                            }
                            SettlerKind::Planer => {
                                f.debug_tuple("SettlerKind::Planer").finish()
                            }
                            SettlerKind::Builder => {
                                f.debug_tuple("SettlerKind::Builder").finish()
                            }
                            SettlerKind::Woodcutter => {
                                f.debug_tuple("SettlerKind::Woodcutter").finish()
                            }
                            SettlerKind::Stonecutter => {
                                f.debug_tuple("SettlerKind::Stonecutter").finish()
                            }
                            SettlerKind::Forester => {
                                f.debug_tuple("SettlerKind::Forester").finish()
                            }
                            SettlerKind::GrainFarmer => {
                                f.debug_tuple("SettlerKind::GrainFarmer").finish()
                            }
                            SettlerKind::AnimalFarmer => {
                                f.debug_tuple("SettlerKind::AnimalFarmer").finish()
                            }
                            SettlerKind::Fisher => {
                                f.debug_tuple("SettlerKind::Fisher").finish()
                            }
                            SettlerKind::Waterworker => {
                                f.debug_tuple("SettlerKind::Waterworker").finish()
                            }
                            SettlerKind::Hunter => {
                                f.debug_tuple("SettlerKind::Hunter").finish()
                            }
                            SettlerKind::SawmillWorker => {
                                f.debug_tuple("SettlerKind::SawmillWorker").finish()
                            }
                            SettlerKind::Smelter => {
                                f.debug_tuple("SettlerKind::Smelter").finish()
                            }
                            SettlerKind::Mineworker => {
                                f.debug_tuple("SettlerKind::Mineworker").finish()
                            }
                            SettlerKind::Smith => {
                                f.debug_tuple("SettlerKind::Smith").finish()
                            }
                            SettlerKind::Miller => {
                                f.debug_tuple("SettlerKind::Miller").finish()
                            }
                            SettlerKind::Baker => {
                                f.debug_tuple("SettlerKind::Baker").finish()
                            }
                            SettlerKind::Butcher => {
                                f.debug_tuple("SettlerKind::Butcher").finish()
                            }
                            SettlerKind::ShipyardWorker => {
                                f.debug_tuple("SettlerKind::ShipyardWorker").finish()
                            }
                            SettlerKind::Healer => {
                                f.debug_tuple("SettlerKind::Healer").finish()
                            }
                            SettlerKind::CharcoalMaker => {
                                f.debug_tuple("SettlerKind::CharcoalMaker").finish()
                            }
                            SettlerKind::AmmoMaker => {
                                f.debug_tuple("SettlerKind::AmmoMaker").finish()
                            }
                            SettlerKind::VehicleMaker => {
                                f.debug_tuple("SettlerKind::VehicleMaker").finish()
                            }
                            SettlerKind::Vinter => {
                                f.debug_tuple("SettlerKind::Vinter").finish()
                            }
                            SettlerKind::Beekeeper => {
                                f.debug_tuple("SettlerKind::Beekeeper").finish()
                            }
                            SettlerKind::Meadmaker => {
                                f.debug_tuple("SettlerKind::Meadmaker").finish()
                            }
                            SettlerKind::AgaveFarmer => {
                                f.debug_tuple("SettlerKind::AgaveFarmer").finish()
                            }
                            SettlerKind::TequilaMaker => {
                                f.debug_tuple("SettlerKind::TequilaMaker").finish()
                            }
                            SettlerKind::Level1Swordsman => {
                                f.debug_tuple("SettlerKind::Level1Swordsman").finish()
                            }
                            SettlerKind::Level2Swordsman => {
                                f.debug_tuple("SettlerKind::Level2Swordsman").finish()
                            }
                            SettlerKind::Level3Swordsman => {
                                f.debug_tuple("SettlerKind::Level3Swordsman").finish()
                            }
                            SettlerKind::Level1Archer => {
                                f.debug_tuple("SettlerKind::Level1Archer").finish()
                            }
                            SettlerKind::Level2Archer => {
                                f.debug_tuple("SettlerKind::Level2Archer").finish()
                            }
                            SettlerKind::Level3Archer => {
                                f.debug_tuple("SettlerKind::Level3Archer").finish()
                            }
                            SettlerKind::Level1Medic => {
                                f.debug_tuple("SettlerKind::Level1Medic").finish()
                            }
                            SettlerKind::Level2Medic => {
                                f.debug_tuple("SettlerKind::Level2Medic").finish()
                            }
                            SettlerKind::Level3Medic => {
                                f.debug_tuple("SettlerKind::Level3Medic").finish()
                            }
                            SettlerKind::Level1AxeWarrior => {
                                f.debug_tuple("SettlerKind::Level1AxeWarrior").finish()
                            }
                            SettlerKind::Level2AxeWarrior => {
                                f.debug_tuple("SettlerKind::Level2AxeWarrior").finish()
                            }
                            SettlerKind::Level3AxeWarrior => {
                                f.debug_tuple("SettlerKind::Level3AxeWarrior").finish()
                            }
                            SettlerKind::Level1Blowgun => {
                                f.debug_tuple("SettlerKind::Level1Blowgun").finish()
                            }
                            SettlerKind::Level2Blowgun => {
                                f.debug_tuple("SettlerKind::Level2Blowgun").finish()
                            }
                            SettlerKind::Level3Blowgun => {
                                f.debug_tuple("SettlerKind::Level3Blowgun").finish()
                            }
                            SettlerKind::SquadLeader => {
                                f.debug_tuple("SettlerKind::SquadLeader").finish()
                            }
                            SettlerKind::Priest => {
                                f.debug_tuple("SettlerKind::Priest").finish()
                            }
                            SettlerKind::Saboteur => {
                                f.debug_tuple("SettlerKind::Saboteur").finish()
                            }
                            SettlerKind::Pioneer => {
                                f.debug_tuple("SettlerKind::Pioneer").finish()
                            }
                            SettlerKind::Thief => {
                                f.debug_tuple("SettlerKind::Thief").finish()
                            }
                            SettlerKind::Geologist => {
                                f.debug_tuple("SettlerKind::Geologist").finish()
                            }
                            SettlerKind::Gardener => {
                                f.debug_tuple("SettlerKind::Gardener").finish()
                            }
                            SettlerKind::Landscaper => {
                                f.debug_tuple("SettlerKind::Landscaper").finish()
                            }
                            SettlerKind::DarkGardener => {
                                f.debug_tuple("SettlerKind::DarkGardener").finish()
                            }
                            SettlerKind::MushroomFarmer => {
                                f.debug_tuple("SettlerKind::MushroomFarmer").finish()
                            }
                            SettlerKind::Shaman => {
                                f.debug_tuple("SettlerKind::Shaman").finish()
                            }
                            SettlerKind::DarkSettler => {
                                f.debug_tuple("SettlerKind::DarkSettler").finish()
                            }
                            SettlerKind::TempleServant => {
                                f.debug_tuple("SettlerKind::TempleServant").finish()
                            }
                            SettlerKind::Level1Angel => {
                                f.debug_tuple("SettlerKind::Level1Angel").finish()
                            }
                            SettlerKind::Level2Angel => {
                                f.debug_tuple("SettlerKind::Level2Angel").finish()
                            }
                            SettlerKind::Level3Angel => {
                                f.debug_tuple("SettlerKind::Level3Angel").finish()
                            }
                            SettlerKind::Donkey => {
                                f.debug_tuple("SettlerKind::Donkey").finish()
                            }
                            SettlerKind::Level1BackpackCatapultist => {
                                f.debug_tuple("SettlerKind::Level1BackpackCatapultist")
                                    .finish()
                            }
                            SettlerKind::Level2BackpackCatapultist => {
                                f.debug_tuple("SettlerKind::Level2BackpackCatapultist")
                                    .finish()
                            }
                            SettlerKind::Level3BackpackCatapultist => {
                                f.debug_tuple("SettlerKind::Level3BackpackCatapultist")
                                    .finish()
                            }
                            SettlerKind::SunflowerFarmer => {
                                f.debug_tuple("SettlerKind::SunflowerFarmer").finish()
                            }
                            SettlerKind::SunoilMaker => {
                                f.debug_tuple("SettlerKind::SunoilMaker").finish()
                            }
                            SettlerKind::ManacopterMaster => {
                                f.debug_tuple("SettlerKind::ManacopterMaster").finish()
                            }
                        }
                    }
                }
                impl SettlerKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> SettlerKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => SettlerKind::Carrier,
                            1 => SettlerKind::Planer,
                            2 => SettlerKind::Builder,
                            3 => SettlerKind::Woodcutter,
                            4 => SettlerKind::Stonecutter,
                            5 => SettlerKind::Forester,
                            6 => SettlerKind::GrainFarmer,
                            7 => SettlerKind::AnimalFarmer,
                            8 => SettlerKind::Fisher,
                            9 => SettlerKind::Waterworker,
                            10 => SettlerKind::Hunter,
                            11 => SettlerKind::SawmillWorker,
                            12 => SettlerKind::Smelter,
                            13 => SettlerKind::Mineworker,
                            14 => SettlerKind::Smith,
                            15 => SettlerKind::Miller,
                            16 => SettlerKind::Baker,
                            17 => SettlerKind::Butcher,
                            18 => SettlerKind::ShipyardWorker,
                            19 => SettlerKind::Healer,
                            20 => SettlerKind::CharcoalMaker,
                            21 => SettlerKind::AmmoMaker,
                            22 => SettlerKind::VehicleMaker,
                            23 => SettlerKind::Vinter,
                            24 => SettlerKind::Beekeeper,
                            25 => SettlerKind::Meadmaker,
                            26 => SettlerKind::AgaveFarmer,
                            27 => SettlerKind::TequilaMaker,
                            28 => SettlerKind::Level1Swordsman,
                            29 => SettlerKind::Level2Swordsman,
                            30 => SettlerKind::Level3Swordsman,
                            31 => SettlerKind::Level1Archer,
                            32 => SettlerKind::Level2Archer,
                            33 => SettlerKind::Level3Archer,
                            34 => SettlerKind::Level1Medic,
                            35 => SettlerKind::Level2Medic,
                            36 => SettlerKind::Level3Medic,
                            37 => SettlerKind::Level1AxeWarrior,
                            38 => SettlerKind::Level2AxeWarrior,
                            39 => SettlerKind::Level3AxeWarrior,
                            40 => SettlerKind::Level1Blowgun,
                            41 => SettlerKind::Level2Blowgun,
                            42 => SettlerKind::Level3Blowgun,
                            43 => SettlerKind::SquadLeader,
                            44 => SettlerKind::Priest,
                            45 => SettlerKind::Saboteur,
                            46 => SettlerKind::Pioneer,
                            47 => SettlerKind::Thief,
                            48 => SettlerKind::Geologist,
                            49 => SettlerKind::Gardener,
                            50 => SettlerKind::Landscaper,
                            51 => SettlerKind::DarkGardener,
                            52 => SettlerKind::MushroomFarmer,
                            53 => SettlerKind::Shaman,
                            54 => SettlerKind::DarkSettler,
                            55 => SettlerKind::TempleServant,
                            56 => SettlerKind::Level1Angel,
                            57 => SettlerKind::Level2Angel,
                            58 => SettlerKind::Level3Angel,
                            59 => SettlerKind::Donkey,
                            60 => SettlerKind::Level1BackpackCatapultist,
                            61 => SettlerKind::Level2BackpackCatapultist,
                            62 => SettlerKind::Level3BackpackCatapultist,
                            63 => SettlerKind::SunflowerFarmer,
                            64 => SettlerKind::SunoilMaker,
                            65 => SettlerKind::ManacopterMaster,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Settler {
                    pub position: (u16, u16),
                    pub kind: SettlerKind,
                    pub team_id: u8,
                }
                impl ::core::fmt::Debug for Settler {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Settler")
                            .field("position", &self.position)
                            .field("kind", &self.kind)
                            .field("team-id", &self.team_id)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum PlayerKind {
                    Human,
                    Computer,
                }
                impl ::core::fmt::Debug for PlayerKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            PlayerKind::Human => {
                                f.debug_tuple("PlayerKind::Human").finish()
                            }
                            PlayerKind::Computer => {
                                f.debug_tuple("PlayerKind::Computer").finish()
                            }
                        }
                    }
                }
                impl PlayerKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> PlayerKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => PlayerKind::Human,
                            1 => PlayerKind::Computer,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum BuildingKind {
                    WoodcuttersHut,
                    ForestersHut,
                    Sawmill,
                    StonecuttersHut,
                    WaterworkersHut,
                    FishersHut,
                    HuntersHut,
                    Slaughterhouse,
                    GrainMill,
                    Bakery,
                    GrainFarm,
                    SheepRanch,
                    DonkeyRanch,
                    StoneMine,
                    IronMine,
                    GoldMine,
                    CoalMine,
                    SulfurMine,
                    GoldSmeltingWorks,
                    IronSmeltingWorks,
                    ToolsmithsWorks,
                    WeaponsmithsWorks,
                    VehicleHall,
                    Barracks,
                    CharcoalMaker,
                    TrainingCenter,
                    HealersQuarters,
                    AmmoMakersWorks,
                    GunpowderMakersHut,
                    LandscapeMakersHut,
                    Shipyard,
                    Harbor,
                    Marketplace,
                    StorageArea,
                    Vineyard,
                    AgaveFarmersHut,
                    TequilaMakersHut,
                    BeekeepersHut,
                    MeadmakersHut,
                    SmallResidence,
                    MediumResidence,
                    LargeResidence,
                    SmallTemple,
                    LargeTemple,
                    LookoutTower,
                    SmallTower,
                    LargeTower,
                    Castle,
                    DarkMushroomFarm,
                    DarkTemple,
                    DarkFortress,
                    HarborA,
                    HarborB,
                    HarborC,
                    HarborD,
                    HarborE,
                    HarborF,
                    ShipyardA,
                    ShipyardB,
                    ShipyardC,
                    ShipyardD,
                    ShipyardE,
                    ShipyardF,
                    Bust,
                    Monument,
                    Standart,
                    Obelisk,
                    Bench,
                    ArchedGateway,
                    FlowerKind1,
                    Tombstone,
                    StonePlaque,
                    Vase,
                    Knight,
                    FlowerKind2,
                    ShipyardG,
                    ShipyardH,
                    HarborG,
                    HarborH,
                    ManacopterHall,
                    SunflowerOilMakersHut,
                    SunflowerFarm,
                }
                impl ::core::fmt::Debug for BuildingKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            BuildingKind::WoodcuttersHut => {
                                f.debug_tuple("BuildingKind::WoodcuttersHut").finish()
                            }
                            BuildingKind::ForestersHut => {
                                f.debug_tuple("BuildingKind::ForestersHut").finish()
                            }
                            BuildingKind::Sawmill => {
                                f.debug_tuple("BuildingKind::Sawmill").finish()
                            }
                            BuildingKind::StonecuttersHut => {
                                f.debug_tuple("BuildingKind::StonecuttersHut").finish()
                            }
                            BuildingKind::WaterworkersHut => {
                                f.debug_tuple("BuildingKind::WaterworkersHut").finish()
                            }
                            BuildingKind::FishersHut => {
                                f.debug_tuple("BuildingKind::FishersHut").finish()
                            }
                            BuildingKind::HuntersHut => {
                                f.debug_tuple("BuildingKind::HuntersHut").finish()
                            }
                            BuildingKind::Slaughterhouse => {
                                f.debug_tuple("BuildingKind::Slaughterhouse").finish()
                            }
                            BuildingKind::GrainMill => {
                                f.debug_tuple("BuildingKind::GrainMill").finish()
                            }
                            BuildingKind::Bakery => {
                                f.debug_tuple("BuildingKind::Bakery").finish()
                            }
                            BuildingKind::GrainFarm => {
                                f.debug_tuple("BuildingKind::GrainFarm").finish()
                            }
                            BuildingKind::SheepRanch => {
                                f.debug_tuple("BuildingKind::SheepRanch").finish()
                            }
                            BuildingKind::DonkeyRanch => {
                                f.debug_tuple("BuildingKind::DonkeyRanch").finish()
                            }
                            BuildingKind::StoneMine => {
                                f.debug_tuple("BuildingKind::StoneMine").finish()
                            }
                            BuildingKind::IronMine => {
                                f.debug_tuple("BuildingKind::IronMine").finish()
                            }
                            BuildingKind::GoldMine => {
                                f.debug_tuple("BuildingKind::GoldMine").finish()
                            }
                            BuildingKind::CoalMine => {
                                f.debug_tuple("BuildingKind::CoalMine").finish()
                            }
                            BuildingKind::SulfurMine => {
                                f.debug_tuple("BuildingKind::SulfurMine").finish()
                            }
                            BuildingKind::GoldSmeltingWorks => {
                                f.debug_tuple("BuildingKind::GoldSmeltingWorks").finish()
                            }
                            BuildingKind::IronSmeltingWorks => {
                                f.debug_tuple("BuildingKind::IronSmeltingWorks").finish()
                            }
                            BuildingKind::ToolsmithsWorks => {
                                f.debug_tuple("BuildingKind::ToolsmithsWorks").finish()
                            }
                            BuildingKind::WeaponsmithsWorks => {
                                f.debug_tuple("BuildingKind::WeaponsmithsWorks").finish()
                            }
                            BuildingKind::VehicleHall => {
                                f.debug_tuple("BuildingKind::VehicleHall").finish()
                            }
                            BuildingKind::Barracks => {
                                f.debug_tuple("BuildingKind::Barracks").finish()
                            }
                            BuildingKind::CharcoalMaker => {
                                f.debug_tuple("BuildingKind::CharcoalMaker").finish()
                            }
                            BuildingKind::TrainingCenter => {
                                f.debug_tuple("BuildingKind::TrainingCenter").finish()
                            }
                            BuildingKind::HealersQuarters => {
                                f.debug_tuple("BuildingKind::HealersQuarters").finish()
                            }
                            BuildingKind::AmmoMakersWorks => {
                                f.debug_tuple("BuildingKind::AmmoMakersWorks").finish()
                            }
                            BuildingKind::GunpowderMakersHut => {
                                f.debug_tuple("BuildingKind::GunpowderMakersHut").finish()
                            }
                            BuildingKind::LandscapeMakersHut => {
                                f.debug_tuple("BuildingKind::LandscapeMakersHut").finish()
                            }
                            BuildingKind::Shipyard => {
                                f.debug_tuple("BuildingKind::Shipyard").finish()
                            }
                            BuildingKind::Harbor => {
                                f.debug_tuple("BuildingKind::Harbor").finish()
                            }
                            BuildingKind::Marketplace => {
                                f.debug_tuple("BuildingKind::Marketplace").finish()
                            }
                            BuildingKind::StorageArea => {
                                f.debug_tuple("BuildingKind::StorageArea").finish()
                            }
                            BuildingKind::Vineyard => {
                                f.debug_tuple("BuildingKind::Vineyard").finish()
                            }
                            BuildingKind::AgaveFarmersHut => {
                                f.debug_tuple("BuildingKind::AgaveFarmersHut").finish()
                            }
                            BuildingKind::TequilaMakersHut => {
                                f.debug_tuple("BuildingKind::TequilaMakersHut").finish()
                            }
                            BuildingKind::BeekeepersHut => {
                                f.debug_tuple("BuildingKind::BeekeepersHut").finish()
                            }
                            BuildingKind::MeadmakersHut => {
                                f.debug_tuple("BuildingKind::MeadmakersHut").finish()
                            }
                            BuildingKind::SmallResidence => {
                                f.debug_tuple("BuildingKind::SmallResidence").finish()
                            }
                            BuildingKind::MediumResidence => {
                                f.debug_tuple("BuildingKind::MediumResidence").finish()
                            }
                            BuildingKind::LargeResidence => {
                                f.debug_tuple("BuildingKind::LargeResidence").finish()
                            }
                            BuildingKind::SmallTemple => {
                                f.debug_tuple("BuildingKind::SmallTemple").finish()
                            }
                            BuildingKind::LargeTemple => {
                                f.debug_tuple("BuildingKind::LargeTemple").finish()
                            }
                            BuildingKind::LookoutTower => {
                                f.debug_tuple("BuildingKind::LookoutTower").finish()
                            }
                            BuildingKind::SmallTower => {
                                f.debug_tuple("BuildingKind::SmallTower").finish()
                            }
                            BuildingKind::LargeTower => {
                                f.debug_tuple("BuildingKind::LargeTower").finish()
                            }
                            BuildingKind::Castle => {
                                f.debug_tuple("BuildingKind::Castle").finish()
                            }
                            BuildingKind::DarkMushroomFarm => {
                                f.debug_tuple("BuildingKind::DarkMushroomFarm").finish()
                            }
                            BuildingKind::DarkTemple => {
                                f.debug_tuple("BuildingKind::DarkTemple").finish()
                            }
                            BuildingKind::DarkFortress => {
                                f.debug_tuple("BuildingKind::DarkFortress").finish()
                            }
                            BuildingKind::HarborA => {
                                f.debug_tuple("BuildingKind::HarborA").finish()
                            }
                            BuildingKind::HarborB => {
                                f.debug_tuple("BuildingKind::HarborB").finish()
                            }
                            BuildingKind::HarborC => {
                                f.debug_tuple("BuildingKind::HarborC").finish()
                            }
                            BuildingKind::HarborD => {
                                f.debug_tuple("BuildingKind::HarborD").finish()
                            }
                            BuildingKind::HarborE => {
                                f.debug_tuple("BuildingKind::HarborE").finish()
                            }
                            BuildingKind::HarborF => {
                                f.debug_tuple("BuildingKind::HarborF").finish()
                            }
                            BuildingKind::ShipyardA => {
                                f.debug_tuple("BuildingKind::ShipyardA").finish()
                            }
                            BuildingKind::ShipyardB => {
                                f.debug_tuple("BuildingKind::ShipyardB").finish()
                            }
                            BuildingKind::ShipyardC => {
                                f.debug_tuple("BuildingKind::ShipyardC").finish()
                            }
                            BuildingKind::ShipyardD => {
                                f.debug_tuple("BuildingKind::ShipyardD").finish()
                            }
                            BuildingKind::ShipyardE => {
                                f.debug_tuple("BuildingKind::ShipyardE").finish()
                            }
                            BuildingKind::ShipyardF => {
                                f.debug_tuple("BuildingKind::ShipyardF").finish()
                            }
                            BuildingKind::Bust => {
                                f.debug_tuple("BuildingKind::Bust").finish()
                            }
                            BuildingKind::Monument => {
                                f.debug_tuple("BuildingKind::Monument").finish()
                            }
                            BuildingKind::Standart => {
                                f.debug_tuple("BuildingKind::Standart").finish()
                            }
                            BuildingKind::Obelisk => {
                                f.debug_tuple("BuildingKind::Obelisk").finish()
                            }
                            BuildingKind::Bench => {
                                f.debug_tuple("BuildingKind::Bench").finish()
                            }
                            BuildingKind::ArchedGateway => {
                                f.debug_tuple("BuildingKind::ArchedGateway").finish()
                            }
                            BuildingKind::FlowerKind1 => {
                                f.debug_tuple("BuildingKind::FlowerKind1").finish()
                            }
                            BuildingKind::Tombstone => {
                                f.debug_tuple("BuildingKind::Tombstone").finish()
                            }
                            BuildingKind::StonePlaque => {
                                f.debug_tuple("BuildingKind::StonePlaque").finish()
                            }
                            BuildingKind::Vase => {
                                f.debug_tuple("BuildingKind::Vase").finish()
                            }
                            BuildingKind::Knight => {
                                f.debug_tuple("BuildingKind::Knight").finish()
                            }
                            BuildingKind::FlowerKind2 => {
                                f.debug_tuple("BuildingKind::FlowerKind2").finish()
                            }
                            BuildingKind::ShipyardG => {
                                f.debug_tuple("BuildingKind::ShipyardG").finish()
                            }
                            BuildingKind::ShipyardH => {
                                f.debug_tuple("BuildingKind::ShipyardH").finish()
                            }
                            BuildingKind::HarborG => {
                                f.debug_tuple("BuildingKind::HarborG").finish()
                            }
                            BuildingKind::HarborH => {
                                f.debug_tuple("BuildingKind::HarborH").finish()
                            }
                            BuildingKind::ManacopterHall => {
                                f.debug_tuple("BuildingKind::ManacopterHall").finish()
                            }
                            BuildingKind::SunflowerOilMakersHut => {
                                f.debug_tuple("BuildingKind::SunflowerOilMakersHut")
                                    .finish()
                            }
                            BuildingKind::SunflowerFarm => {
                                f.debug_tuple("BuildingKind::SunflowerFarm").finish()
                            }
                        }
                    }
                }
                impl BuildingKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> BuildingKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => BuildingKind::WoodcuttersHut,
                            1 => BuildingKind::ForestersHut,
                            2 => BuildingKind::Sawmill,
                            3 => BuildingKind::StonecuttersHut,
                            4 => BuildingKind::WaterworkersHut,
                            5 => BuildingKind::FishersHut,
                            6 => BuildingKind::HuntersHut,
                            7 => BuildingKind::Slaughterhouse,
                            8 => BuildingKind::GrainMill,
                            9 => BuildingKind::Bakery,
                            10 => BuildingKind::GrainFarm,
                            11 => BuildingKind::SheepRanch,
                            12 => BuildingKind::DonkeyRanch,
                            13 => BuildingKind::StoneMine,
                            14 => BuildingKind::IronMine,
                            15 => BuildingKind::GoldMine,
                            16 => BuildingKind::CoalMine,
                            17 => BuildingKind::SulfurMine,
                            18 => BuildingKind::GoldSmeltingWorks,
                            19 => BuildingKind::IronSmeltingWorks,
                            20 => BuildingKind::ToolsmithsWorks,
                            21 => BuildingKind::WeaponsmithsWorks,
                            22 => BuildingKind::VehicleHall,
                            23 => BuildingKind::Barracks,
                            24 => BuildingKind::CharcoalMaker,
                            25 => BuildingKind::TrainingCenter,
                            26 => BuildingKind::HealersQuarters,
                            27 => BuildingKind::AmmoMakersWorks,
                            28 => BuildingKind::GunpowderMakersHut,
                            29 => BuildingKind::LandscapeMakersHut,
                            30 => BuildingKind::Shipyard,
                            31 => BuildingKind::Harbor,
                            32 => BuildingKind::Marketplace,
                            33 => BuildingKind::StorageArea,
                            34 => BuildingKind::Vineyard,
                            35 => BuildingKind::AgaveFarmersHut,
                            36 => BuildingKind::TequilaMakersHut,
                            37 => BuildingKind::BeekeepersHut,
                            38 => BuildingKind::MeadmakersHut,
                            39 => BuildingKind::SmallResidence,
                            40 => BuildingKind::MediumResidence,
                            41 => BuildingKind::LargeResidence,
                            42 => BuildingKind::SmallTemple,
                            43 => BuildingKind::LargeTemple,
                            44 => BuildingKind::LookoutTower,
                            45 => BuildingKind::SmallTower,
                            46 => BuildingKind::LargeTower,
                            47 => BuildingKind::Castle,
                            48 => BuildingKind::DarkMushroomFarm,
                            49 => BuildingKind::DarkTemple,
                            50 => BuildingKind::DarkFortress,
                            51 => BuildingKind::HarborA,
                            52 => BuildingKind::HarborB,
                            53 => BuildingKind::HarborC,
                            54 => BuildingKind::HarborD,
                            55 => BuildingKind::HarborE,
                            56 => BuildingKind::HarborF,
                            57 => BuildingKind::ShipyardA,
                            58 => BuildingKind::ShipyardB,
                            59 => BuildingKind::ShipyardC,
                            60 => BuildingKind::ShipyardD,
                            61 => BuildingKind::ShipyardE,
                            62 => BuildingKind::ShipyardF,
                            63 => BuildingKind::Bust,
                            64 => BuildingKind::Monument,
                            65 => BuildingKind::Standart,
                            66 => BuildingKind::Obelisk,
                            67 => BuildingKind::Bench,
                            68 => BuildingKind::ArchedGateway,
                            69 => BuildingKind::FlowerKind1,
                            70 => BuildingKind::Tombstone,
                            71 => BuildingKind::StonePlaque,
                            72 => BuildingKind::Vase,
                            73 => BuildingKind::Knight,
                            74 => BuildingKind::FlowerKind2,
                            75 => BuildingKind::ShipyardG,
                            76 => BuildingKind::ShipyardH,
                            77 => BuildingKind::HarborG,
                            78 => BuildingKind::HarborH,
                            79 => BuildingKind::ManacopterHall,
                            80 => BuildingKind::SunflowerOilMakersHut,
                            81 => BuildingKind::SunflowerFarm,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Building {
                    pub position: (u16, u16),
                    pub kind: BuildingKind,
                    pub team_id: u8,
                    pub is_occupied: bool,
                    pub level1_swordsmen: u8,
                    pub level2_swordsmen: u8,
                    pub level3_swordsmen: u8,
                    pub level1_archers: u8,
                    pub level2_archers: u8,
                    pub level3_archers: u8,
                }
                impl ::core::fmt::Debug for Building {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Building")
                            .field("position", &self.position)
                            .field("kind", &self.kind)
                            .field("team-id", &self.team_id)
                            .field("is-occupied", &self.is_occupied)
                            .field("level1-swordsmen", &self.level1_swordsmen)
                            .field("level2-swordsmen", &self.level2_swordsmen)
                            .field("level3-swordsmen", &self.level3_swordsmen)
                            .field("level1-archers", &self.level1_archers)
                            .field("level2-archers", &self.level2_archers)
                            .field("level3-archers", &self.level3_archers)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum Gamemode {
                    Versus,
                    Single,
                    Coop,
                }
                impl ::core::fmt::Debug for Gamemode {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Gamemode::Versus => {
                                f.debug_tuple("Gamemode::Versus").finish()
                            }
                            Gamemode::Single => {
                                f.debug_tuple("Gamemode::Single").finish()
                            }
                            Gamemode::Coop => f.debug_tuple("Gamemode::Coop").finish(),
                        }
                    }
                }
                impl Gamemode {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> Gamemode {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => Gamemode::Versus,
                            1 => Gamemode::Single,
                            2 => Gamemode::Coop,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum ResourceRichness {
                    Low,
                    Medium,
                    High,
                }
                impl ::core::fmt::Debug for ResourceRichness {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            ResourceRichness::Low => {
                                f.debug_tuple("ResourceRichness::Low").finish()
                            }
                            ResourceRichness::Medium => {
                                f.debug_tuple("ResourceRichness::Medium").finish()
                            }
                            ResourceRichness::High => {
                                f.debug_tuple("ResourceRichness::High").finish()
                            }
                        }
                    }
                }
                impl ResourceRichness {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> ResourceRichness {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => ResourceRichness::Low,
                            1 => ResourceRichness::Medium,
                            2 => ResourceRichness::High,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum Tribe {
                    Roman,
                    Mayan,
                    Viking,
                    Dark,
                    Trojan,
                }
                impl ::core::fmt::Debug for Tribe {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Tribe::Roman => f.debug_tuple("Tribe::Roman").finish(),
                            Tribe::Mayan => f.debug_tuple("Tribe::Mayan").finish(),
                            Tribe::Viking => f.debug_tuple("Tribe::Viking").finish(),
                            Tribe::Dark => f.debug_tuple("Tribe::Dark").finish(),
                            Tribe::Trojan => f.debug_tuple("Tribe::Trojan").finish(),
                        }
                    }
                }
                impl Tribe {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> Tribe {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => Tribe::Roman,
                            1 => Tribe::Mayan,
                            2 => Tribe::Viking,
                            3 => Tribe::Dark,
                            4 => Tribe::Trojan,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                wit_bindgen_rt::bitflags::bitflags! {
                    #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
                    pub struct GroundMeta : u8 { const UNKNOWN = 1 << 0; }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum GroundKind {
                    WaterLevel1,
                    WaterLevel2,
                    WaterLevel3,
                    WaterLevel4,
                    WaterLevel5,
                    WaterLevel6,
                    WaterLevel7,
                    WaterLevel8,
                    WaterBeach,
                    Grass,
                    GrassMountain,
                    GrassIsland,
                    GrassDesert,
                    GrassSwamp,
                    GrassMud,
                    GrassDark,
                    GrassWeird,
                    GrassDusty,
                    GrassPavement,
                    Mountain,
                    MountainGrass,
                    MountainSnow,
                    Beach,
                    Desert,
                    DesertGrass,
                    Swamp,
                    SwampGrass,
                    RiverWidth1,
                    RiverWidth2,
                    RiverWidth3,
                    RiverWidth4,
                    Snow,
                    SnowMountain,
                    Mud,
                    MudGrass,
                    Glitched,
                }
                impl ::core::fmt::Debug for GroundKind {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            GroundKind::WaterLevel1 => {
                                f.debug_tuple("GroundKind::WaterLevel1").finish()
                            }
                            GroundKind::WaterLevel2 => {
                                f.debug_tuple("GroundKind::WaterLevel2").finish()
                            }
                            GroundKind::WaterLevel3 => {
                                f.debug_tuple("GroundKind::WaterLevel3").finish()
                            }
                            GroundKind::WaterLevel4 => {
                                f.debug_tuple("GroundKind::WaterLevel4").finish()
                            }
                            GroundKind::WaterLevel5 => {
                                f.debug_tuple("GroundKind::WaterLevel5").finish()
                            }
                            GroundKind::WaterLevel6 => {
                                f.debug_tuple("GroundKind::WaterLevel6").finish()
                            }
                            GroundKind::WaterLevel7 => {
                                f.debug_tuple("GroundKind::WaterLevel7").finish()
                            }
                            GroundKind::WaterLevel8 => {
                                f.debug_tuple("GroundKind::WaterLevel8").finish()
                            }
                            GroundKind::WaterBeach => {
                                f.debug_tuple("GroundKind::WaterBeach").finish()
                            }
                            GroundKind::Grass => {
                                f.debug_tuple("GroundKind::Grass").finish()
                            }
                            GroundKind::GrassMountain => {
                                f.debug_tuple("GroundKind::GrassMountain").finish()
                            }
                            GroundKind::GrassIsland => {
                                f.debug_tuple("GroundKind::GrassIsland").finish()
                            }
                            GroundKind::GrassDesert => {
                                f.debug_tuple("GroundKind::GrassDesert").finish()
                            }
                            GroundKind::GrassSwamp => {
                                f.debug_tuple("GroundKind::GrassSwamp").finish()
                            }
                            GroundKind::GrassMud => {
                                f.debug_tuple("GroundKind::GrassMud").finish()
                            }
                            GroundKind::GrassDark => {
                                f.debug_tuple("GroundKind::GrassDark").finish()
                            }
                            GroundKind::GrassWeird => {
                                f.debug_tuple("GroundKind::GrassWeird").finish()
                            }
                            GroundKind::GrassDusty => {
                                f.debug_tuple("GroundKind::GrassDusty").finish()
                            }
                            GroundKind::GrassPavement => {
                                f.debug_tuple("GroundKind::GrassPavement").finish()
                            }
                            GroundKind::Mountain => {
                                f.debug_tuple("GroundKind::Mountain").finish()
                            }
                            GroundKind::MountainGrass => {
                                f.debug_tuple("GroundKind::MountainGrass").finish()
                            }
                            GroundKind::MountainSnow => {
                                f.debug_tuple("GroundKind::MountainSnow").finish()
                            }
                            GroundKind::Beach => {
                                f.debug_tuple("GroundKind::Beach").finish()
                            }
                            GroundKind::Desert => {
                                f.debug_tuple("GroundKind::Desert").finish()
                            }
                            GroundKind::DesertGrass => {
                                f.debug_tuple("GroundKind::DesertGrass").finish()
                            }
                            GroundKind::Swamp => {
                                f.debug_tuple("GroundKind::Swamp").finish()
                            }
                            GroundKind::SwampGrass => {
                                f.debug_tuple("GroundKind::SwampGrass").finish()
                            }
                            GroundKind::RiverWidth1 => {
                                f.debug_tuple("GroundKind::RiverWidth1").finish()
                            }
                            GroundKind::RiverWidth2 => {
                                f.debug_tuple("GroundKind::RiverWidth2").finish()
                            }
                            GroundKind::RiverWidth3 => {
                                f.debug_tuple("GroundKind::RiverWidth3").finish()
                            }
                            GroundKind::RiverWidth4 => {
                                f.debug_tuple("GroundKind::RiverWidth4").finish()
                            }
                            GroundKind::Snow => {
                                f.debug_tuple("GroundKind::Snow").finish()
                            }
                            GroundKind::SnowMountain => {
                                f.debug_tuple("GroundKind::SnowMountain").finish()
                            }
                            GroundKind::Mud => f.debug_tuple("GroundKind::Mud").finish(),
                            GroundKind::MudGrass => {
                                f.debug_tuple("GroundKind::MudGrass").finish()
                            }
                            GroundKind::Glitched => {
                                f.debug_tuple("GroundKind::Glitched").finish()
                            }
                        }
                    }
                }
                impl GroundKind {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> GroundKind {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => GroundKind::WaterLevel1,
                            1 => GroundKind::WaterLevel2,
                            2 => GroundKind::WaterLevel3,
                            3 => GroundKind::WaterLevel4,
                            4 => GroundKind::WaterLevel5,
                            5 => GroundKind::WaterLevel6,
                            6 => GroundKind::WaterLevel7,
                            7 => GroundKind::WaterLevel8,
                            8 => GroundKind::WaterBeach,
                            9 => GroundKind::Grass,
                            10 => GroundKind::GrassMountain,
                            11 => GroundKind::GrassIsland,
                            12 => GroundKind::GrassDesert,
                            13 => GroundKind::GrassSwamp,
                            14 => GroundKind::GrassMud,
                            15 => GroundKind::GrassDark,
                            16 => GroundKind::GrassWeird,
                            17 => GroundKind::GrassDusty,
                            18 => GroundKind::GrassPavement,
                            19 => GroundKind::Mountain,
                            20 => GroundKind::MountainGrass,
                            21 => GroundKind::MountainSnow,
                            22 => GroundKind::Beach,
                            23 => GroundKind::Desert,
                            24 => GroundKind::DesertGrass,
                            25 => GroundKind::Swamp,
                            26 => GroundKind::SwampGrass,
                            27 => GroundKind::RiverWidth1,
                            28 => GroundKind::RiverWidth2,
                            29 => GroundKind::RiverWidth3,
                            30 => GroundKind::RiverWidth4,
                            31 => GroundKind::Snow,
                            32 => GroundKind::SnowMountain,
                            33 => GroundKind::Mud,
                            34 => GroundKind::MudGrass,
                            35 => GroundKind::Glitched,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Ground {
                    pub elevation: u8,
                    pub kind: GroundKind,
                    pub meta: GroundMeta,
                }
                impl ::core::fmt::Debug for Ground {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Ground")
                            .field("elevation", &self.elevation)
                            .field("kind", &self.kind)
                            .field("meta", &self.meta)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Info {
                    pub gamemode: Gamemode,
                    pub player_limit: u8,
                    pub resource_richness: Option<ResourceRichness>,
                    pub map_size: u32,
                }
                impl ::core::fmt::Debug for Info {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Info")
                            .field("gamemode", &self.gamemode)
                            .field("player-limit", &self.player_limit)
                            .field("resource-richness", &self.resource_richness)
                            .field("map-size", &self.map_size)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub struct VictoryConditions {
                    pub players_to_defeat: Option<_rt::Vec<bool>>,
                    pub buildings_to_destroy: Option<_rt::Vec<Building>>,
                    pub ground_to_claim: Option<_rt::Vec<(bool, (u16, u16))>>,
                    pub seconds_to_survive: Option<_rt::Vec<u16>>,
                    pub resources_to_gather: Option<_rt::Vec<(u16, WareKind)>>,
                }
                impl ::core::fmt::Debug for VictoryConditions {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("VictoryConditions")
                            .field("players-to-defeat", &self.players_to_defeat)
                            .field("buildings-to-destroy", &self.buildings_to_destroy)
                            .field("ground-to-claim", &self.ground_to_claim)
                            .field("seconds-to-survive", &self.seconds_to_survive)
                            .field("resources-to-gather", &self.resources_to_gather)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub struct Map {
                    pub nature: _rt::Vec<u8>,
                    pub settlers: _rt::Vec<Settler>,
                    pub buildings: _rt::Vec<Building>,
                    pub wares: _rt::Vec<WareStack>,
                    pub victory_conditions: VictoryConditions,
                    pub mission_description: _rt::String,
                    pub mission_hint: _rt::String,
                    pub lua_script: _rt::String,
                    pub landscape: _rt::Vec<Ground>,
                }
                impl ::core::fmt::Debug for Map {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Map")
                            .field("nature", &self.nature)
                            .field("settlers", &self.settlers)
                            .field("buildings", &self.buildings)
                            .field("wares", &self.wares)
                            .field("victory-conditions", &self.victory_conditions)
                            .field("mission-description", &self.mission_description)
                            .field("mission-hint", &self.mission_hint)
                            .field("lua-script", &self.lua_script)
                            .field("landscape", &self.landscape)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_load_map_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::load_map(_rt::string_lift(bytes0));
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let Map {
                                nature: nature3,
                                settlers: settlers3,
                                buildings: buildings3,
                                wares: wares3,
                                victory_conditions: victory_conditions3,
                                mission_description: mission_description3,
                                mission_hint: mission_hint3,
                                lua_script: lua_script3,
                                landscape: landscape3,
                            } = e;
                            let vec4 = (nature3).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2.add(8).cast::<usize>() = len4;
                            *ptr2.add(4).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec7 = settlers3;
                            let len7 = vec7.len();
                            let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec7.len() * 6,
                                2,
                            );
                            let result7 = if layout7.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout7);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec7.into_iter().enumerate() {
                                let base = result7.add(i * 6);
                                {
                                    let Settler {
                                        position: position5,
                                        kind: kind5,
                                        team_id: team_id5,
                                    } = e;
                                    let (t6_0, t6_1) = position5;
                                    *base.add(0).cast::<u16>() = (_rt::as_i32(t6_0)) as u16;
                                    *base.add(2).cast::<u16>() = (_rt::as_i32(t6_1)) as u16;
                                    *base.add(4).cast::<u8>() = (kind5.clone() as i32) as u8;
                                    *base.add(5).cast::<u8>() = (_rt::as_i32(team_id5)) as u8;
                                }
                            }
                            *ptr2.add(16).cast::<usize>() = len7;
                            *ptr2.add(12).cast::<*mut u8>() = result7;
                            let vec10 = buildings3;
                            let len10 = vec10.len();
                            let layout10 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec10.len() * 14,
                                2,
                            );
                            let result10 = if layout10.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout10).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout10);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec10.into_iter().enumerate() {
                                let base = result10.add(i * 14);
                                {
                                    let Building {
                                        position: position8,
                                        kind: kind8,
                                        team_id: team_id8,
                                        is_occupied: is_occupied8,
                                        level1_swordsmen: level1_swordsmen8,
                                        level2_swordsmen: level2_swordsmen8,
                                        level3_swordsmen: level3_swordsmen8,
                                        level1_archers: level1_archers8,
                                        level2_archers: level2_archers8,
                                        level3_archers: level3_archers8,
                                    } = e;
                                    let (t9_0, t9_1) = position8;
                                    *base.add(0).cast::<u16>() = (_rt::as_i32(t9_0)) as u16;
                                    *base.add(2).cast::<u16>() = (_rt::as_i32(t9_1)) as u16;
                                    *base.add(4).cast::<u8>() = (kind8.clone() as i32) as u8;
                                    *base.add(5).cast::<u8>() = (_rt::as_i32(team_id8)) as u8;
                                    *base.add(6).cast::<u8>() = (match is_occupied8 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    *base.add(7).cast::<u8>() = (_rt::as_i32(level1_swordsmen8))
                                        as u8;
                                    *base.add(8).cast::<u8>() = (_rt::as_i32(level2_swordsmen8))
                                        as u8;
                                    *base.add(9).cast::<u8>() = (_rt::as_i32(level3_swordsmen8))
                                        as u8;
                                    *base.add(10).cast::<u8>() = (_rt::as_i32(level1_archers8))
                                        as u8;
                                    *base.add(11).cast::<u8>() = (_rt::as_i32(level2_archers8))
                                        as u8;
                                    *base.add(12).cast::<u8>() = (_rt::as_i32(level3_archers8))
                                        as u8;
                                }
                            }
                            *ptr2.add(24).cast::<usize>() = len10;
                            *ptr2.add(20).cast::<*mut u8>() = result10;
                            let vec12 = wares3;
                            let len12 = vec12.len();
                            let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec12.len() * 2,
                                1,
                            );
                            let result12 = if layout12.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout12);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec12.into_iter().enumerate() {
                                let base = result12.add(i * 2);
                                {
                                    let WareStack { size: size11, kind: kind11 } = e;
                                    *base.add(0).cast::<u8>() = (_rt::as_i32(size11)) as u8;
                                    *base.add(1).cast::<u8>() = (kind11.clone() as i32) as u8;
                                }
                            }
                            *ptr2.add(32).cast::<usize>() = len12;
                            *ptr2.add(28).cast::<*mut u8>() = result12;
                            let VictoryConditions {
                                players_to_defeat: players_to_defeat13,
                                buildings_to_destroy: buildings_to_destroy13,
                                ground_to_claim: ground_to_claim13,
                                seconds_to_survive: seconds_to_survive13,
                                resources_to_gather: resources_to_gather13,
                            } = victory_conditions3;
                            match players_to_defeat13 {
                                Some(e) => {
                                    *ptr2.add(36).cast::<u8>() = (1i32) as u8;
                                    let vec14 = e;
                                    let len14 = vec14.len();
                                    let layout14 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec14.len() * 1,
                                        1,
                                    );
                                    let result14 = if layout14.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout14).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout14);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec14.into_iter().enumerate() {
                                        let base = result14.add(i * 1);
                                        {
                                            *base.add(0).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                        }
                                    }
                                    *ptr2.add(44).cast::<usize>() = len14;
                                    *ptr2.add(40).cast::<*mut u8>() = result14;
                                }
                                None => {
                                    *ptr2.add(36).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match buildings_to_destroy13 {
                                Some(e) => {
                                    *ptr2.add(48).cast::<u8>() = (1i32) as u8;
                                    let vec17 = e;
                                    let len17 = vec17.len();
                                    let layout17 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec17.len() * 14,
                                        2,
                                    );
                                    let result17 = if layout17.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout17).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout17);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec17.into_iter().enumerate() {
                                        let base = result17.add(i * 14);
                                        {
                                            let Building {
                                                position: position15,
                                                kind: kind15,
                                                team_id: team_id15,
                                                is_occupied: is_occupied15,
                                                level1_swordsmen: level1_swordsmen15,
                                                level2_swordsmen: level2_swordsmen15,
                                                level3_swordsmen: level3_swordsmen15,
                                                level1_archers: level1_archers15,
                                                level2_archers: level2_archers15,
                                                level3_archers: level3_archers15,
                                            } = e;
                                            let (t16_0, t16_1) = position15;
                                            *base.add(0).cast::<u16>() = (_rt::as_i32(t16_0)) as u16;
                                            *base.add(2).cast::<u16>() = (_rt::as_i32(t16_1)) as u16;
                                            *base.add(4).cast::<u8>() = (kind15.clone() as i32) as u8;
                                            *base.add(5).cast::<u8>() = (_rt::as_i32(team_id15)) as u8;
                                            *base.add(6).cast::<u8>() = (match is_occupied15 {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                            *base.add(7).cast::<u8>() = (_rt::as_i32(
                                                level1_swordsmen15,
                                            )) as u8;
                                            *base.add(8).cast::<u8>() = (_rt::as_i32(
                                                level2_swordsmen15,
                                            )) as u8;
                                            *base.add(9).cast::<u8>() = (_rt::as_i32(
                                                level3_swordsmen15,
                                            )) as u8;
                                            *base.add(10).cast::<u8>() = (_rt::as_i32(level1_archers15))
                                                as u8;
                                            *base.add(11).cast::<u8>() = (_rt::as_i32(level2_archers15))
                                                as u8;
                                            *base.add(12).cast::<u8>() = (_rt::as_i32(level3_archers15))
                                                as u8;
                                        }
                                    }
                                    *ptr2.add(56).cast::<usize>() = len17;
                                    *ptr2.add(52).cast::<*mut u8>() = result17;
                                }
                                None => {
                                    *ptr2.add(48).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match ground_to_claim13 {
                                Some(e) => {
                                    *ptr2.add(60).cast::<u8>() = (1i32) as u8;
                                    let vec20 = e;
                                    let len20 = vec20.len();
                                    let layout20 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec20.len() * 6,
                                        2,
                                    );
                                    let result20 = if layout20.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout20).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout20);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec20.into_iter().enumerate() {
                                        let base = result20.add(i * 6);
                                        {
                                            let (t18_0, t18_1) = e;
                                            *base.add(0).cast::<u8>() = (match t18_0 {
                                                true => 1,
                                                false => 0,
                                            }) as u8;
                                            let (t19_0, t19_1) = t18_1;
                                            *base.add(2).cast::<u16>() = (_rt::as_i32(t19_0)) as u16;
                                            *base.add(4).cast::<u16>() = (_rt::as_i32(t19_1)) as u16;
                                        }
                                    }
                                    *ptr2.add(68).cast::<usize>() = len20;
                                    *ptr2.add(64).cast::<*mut u8>() = result20;
                                }
                                None => {
                                    *ptr2.add(60).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match seconds_to_survive13 {
                                Some(e) => {
                                    *ptr2.add(72).cast::<u8>() = (1i32) as u8;
                                    let vec21 = (e).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr2.add(80).cast::<usize>() = len21;
                                    *ptr2.add(76).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                None => {
                                    *ptr2.add(72).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match resources_to_gather13 {
                                Some(e) => {
                                    *ptr2.add(84).cast::<u8>() = (1i32) as u8;
                                    let vec23 = e;
                                    let len23 = vec23.len();
                                    let layout23 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec23.len() * 4,
                                        2,
                                    );
                                    let result23 = if layout23.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout23);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec23.into_iter().enumerate() {
                                        let base = result23.add(i * 4);
                                        {
                                            let (t22_0, t22_1) = e;
                                            *base.add(0).cast::<u16>() = (_rt::as_i32(t22_0)) as u16;
                                            *base.add(2).cast::<u8>() = (t22_1.clone() as i32) as u8;
                                        }
                                    }
                                    *ptr2.add(92).cast::<usize>() = len23;
                                    *ptr2.add(88).cast::<*mut u8>() = result23;
                                }
                                None => {
                                    *ptr2.add(84).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec24 = (mission_description3.into_bytes())
                                .into_boxed_slice();
                            let ptr24 = vec24.as_ptr().cast::<u8>();
                            let len24 = vec24.len();
                            ::core::mem::forget(vec24);
                            *ptr2.add(100).cast::<usize>() = len24;
                            *ptr2.add(96).cast::<*mut u8>() = ptr24.cast_mut();
                            let vec25 = (mission_hint3.into_bytes()).into_boxed_slice();
                            let ptr25 = vec25.as_ptr().cast::<u8>();
                            let len25 = vec25.len();
                            ::core::mem::forget(vec25);
                            *ptr2.add(108).cast::<usize>() = len25;
                            *ptr2.add(104).cast::<*mut u8>() = ptr25.cast_mut();
                            let vec26 = (lua_script3.into_bytes()).into_boxed_slice();
                            let ptr26 = vec26.as_ptr().cast::<u8>();
                            let len26 = vec26.len();
                            ::core::mem::forget(vec26);
                            *ptr2.add(116).cast::<usize>() = len26;
                            *ptr2.add(112).cast::<*mut u8>() = ptr26.cast_mut();
                            let vec29 = landscape3;
                            let len29 = vec29.len();
                            let layout29 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec29.len() * 3,
                                1,
                            );
                            let result29 = if layout29.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout29).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout29);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec29.into_iter().enumerate() {
                                let base = result29.add(i * 3);
                                {
                                    let Ground {
                                        elevation: elevation27,
                                        kind: kind27,
                                        meta: meta27,
                                    } = e;
                                    *base.add(0).cast::<u8>() = (_rt::as_i32(elevation27))
                                        as u8;
                                    *base.add(1).cast::<u8>() = (kind27.clone() as i32) as u8;
                                    let flags28 = meta27;
                                    *base.add(2).cast::<u8>() = ((flags28.bits() >> 0) as i32)
                                        as u8;
                                }
                            }
                            *ptr2.add(124).cast::<usize>() = len29;
                            *ptr2.add(120).cast::<*mut u8>() = result29;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec30 = (e.into_bytes()).into_boxed_slice();
                            let ptr30 = vec30.as_ptr().cast::<u8>();
                            let len30 = vec30.len();
                            ::core::mem::forget(vec30);
                            *ptr2.add(8).cast::<usize>() = len30;
                            *ptr2.add(4).cast::<*mut u8>() = ptr30.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_load_map<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                            let l4 = *arg0.add(12).cast::<*mut u8>();
                            let l5 = *arg0.add(16).cast::<usize>();
                            let base6 = l4;
                            let len6 = l5;
                            _rt::cabi_dealloc(base6, len6 * 6, 2);
                            let l7 = *arg0.add(20).cast::<*mut u8>();
                            let l8 = *arg0.add(24).cast::<usize>();
                            let base9 = l7;
                            let len9 = l8;
                            _rt::cabi_dealloc(base9, len9 * 14, 2);
                            let l10 = *arg0.add(28).cast::<*mut u8>();
                            let l11 = *arg0.add(32).cast::<usize>();
                            let base12 = l10;
                            let len12 = l11;
                            _rt::cabi_dealloc(base12, len12 * 2, 1);
                            let l13 = i32::from(*arg0.add(36).cast::<u8>());
                            match l13 {
                                0 => {}
                                _ => {
                                    let l14 = *arg0.add(40).cast::<*mut u8>();
                                    let l15 = *arg0.add(44).cast::<usize>();
                                    let base16 = l14;
                                    let len16 = l15;
                                    _rt::cabi_dealloc(base16, len16 * 1, 1);
                                }
                            }
                            let l17 = i32::from(*arg0.add(48).cast::<u8>());
                            match l17 {
                                0 => {}
                                _ => {
                                    let l18 = *arg0.add(52).cast::<*mut u8>();
                                    let l19 = *arg0.add(56).cast::<usize>();
                                    let base20 = l18;
                                    let len20 = l19;
                                    _rt::cabi_dealloc(base20, len20 * 14, 2);
                                }
                            }
                            let l21 = i32::from(*arg0.add(60).cast::<u8>());
                            match l21 {
                                0 => {}
                                _ => {
                                    let l22 = *arg0.add(64).cast::<*mut u8>();
                                    let l23 = *arg0.add(68).cast::<usize>();
                                    let base24 = l22;
                                    let len24 = l23;
                                    _rt::cabi_dealloc(base24, len24 * 6, 2);
                                }
                            }
                            let l25 = i32::from(*arg0.add(72).cast::<u8>());
                            match l25 {
                                0 => {}
                                _ => {
                                    let l26 = *arg0.add(76).cast::<*mut u8>();
                                    let l27 = *arg0.add(80).cast::<usize>();
                                    let base28 = l26;
                                    let len28 = l27;
                                    _rt::cabi_dealloc(base28, len28 * 2, 2);
                                }
                            }
                            let l29 = i32::from(*arg0.add(84).cast::<u8>());
                            match l29 {
                                0 => {}
                                _ => {
                                    let l30 = *arg0.add(88).cast::<*mut u8>();
                                    let l31 = *arg0.add(92).cast::<usize>();
                                    let base32 = l30;
                                    let len32 = l31;
                                    _rt::cabi_dealloc(base32, len32 * 4, 2);
                                }
                            }
                            let l33 = *arg0.add(96).cast::<*mut u8>();
                            let l34 = *arg0.add(100).cast::<usize>();
                            _rt::cabi_dealloc(l33, l34, 1);
                            let l35 = *arg0.add(104).cast::<*mut u8>();
                            let l36 = *arg0.add(108).cast::<usize>();
                            _rt::cabi_dealloc(l35, l36, 1);
                            let l37 = *arg0.add(112).cast::<*mut u8>();
                            let l38 = *arg0.add(116).cast::<usize>();
                            _rt::cabi_dealloc(l37, l38, 1);
                            let l39 = *arg0.add(120).cast::<*mut u8>();
                            let l40 = *arg0.add(124).cast::<usize>();
                            let base41 = l39;
                            let len41 = l40;
                            _rt::cabi_dealloc(base41, len41 * 3, 1);
                        }
                        _ => {
                            let l42 = *arg0.add(4).cast::<*mut u8>();
                            let l43 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l42, l43, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_load_map_info_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::load_map_info(_rt::string_lift(bytes0));
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let Info {
                                gamemode: gamemode3,
                                player_limit: player_limit3,
                                resource_richness: resource_richness3,
                                map_size: map_size3,
                            } = e;
                            *ptr2.add(4).cast::<u8>() = (gamemode3.clone() as i32) as u8;
                            *ptr2.add(5).cast::<u8>() = (_rt::as_i32(player_limit3))
                                as u8;
                            match resource_richness3 {
                                Some(e) => {
                                    *ptr2.add(6).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(7).cast::<u8>() = (e.clone() as i32) as u8;
                                }
                                None => {
                                    *ptr2.add(6).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            *ptr2.add(8).cast::<i32>() = _rt::as_i32(map_size3);
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2.add(8).cast::<usize>() = len4;
                            *ptr2.add(4).cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_load_map_info<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                pub trait Guest {
                    fn load_map(path: _rt::String) -> Result<Map, _rt::String>;
                    fn load_map_info(path: _rt::String) -> Result<Info, _rt::String>;
                }
                #[doc(hidden)]
                macro_rules! __export_s4_files_load_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name = "s4:files/load@0.1.0#load-map"]
                        unsafe extern "C" fn export_load_map(arg0 : * mut u8, arg1 :
                        usize,) -> * mut u8 { $($path_to_types)*::
                        _export_load_map_cabi::<$ty > (arg0, arg1) } #[export_name =
                        "cabi_post_s4:files/load@0.1.0#load-map"] unsafe extern "C" fn
                        _post_return_load_map(arg0 : * mut u8,) { $($path_to_types)*::
                        __post_return_load_map::<$ty > (arg0) } #[export_name =
                        "s4:files/load@0.1.0#load-map-info"] unsafe extern "C" fn
                        export_load_map_info(arg0 : * mut u8, arg1 : usize,) -> * mut u8
                        { $($path_to_types)*:: _export_load_map_info_cabi::<$ty > (arg0,
                        arg1) } #[export_name =
                        "cabi_post_s4:files/load@0.1.0#load-map-info"] unsafe extern "C"
                        fn _post_return_load_map_info(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_load_map_info::<$ty > (arg0) }
                        };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_s4_files_load_0_1_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 128]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 128],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    pub use alloc_crate::vec::Vec;
    pub use alloc_crate::string::String;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub use alloc_crate::alloc;
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_files_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::s4::files::load::__export_s4_files_load_0_1_0_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::s4::files::load);
    };
}
#[doc(inline)]
pub(crate) use __export_files_impl as export;
#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.36.0:s4:files@0.1.0:files:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3989] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x99\x1e\x01A\x02\x01\
A\x06\x01B\x04\x01p}\x01j\x01\0\x01s\x01@\x01\x05input\0\0\x01\x04\0\x0adecompre\
ss\x01\x02\x03\0\x1fs4:compression/decompress@0.1.0\x05\0\x01B\x03\x01p}\x01@\x01\
\x05input\0\0\0\x04\0\x07decrypt\x01\x01\x03\0\x1es4:encryption/decryption@0.1.0\
\x05\x01\x01BA\x01m*\x05agave\x04ammo\x05armor\x03axe\x0abattle-axe\x07blowgun\x05\
board\x03bow\x05bread\x04coal\x04fish\x05flour\x04goat\x04gold\x08gold-ore\x05gr\
ain\x09gunpowder\x06hammer\x05honey\x04iron\x08iron-ore\x03log\x04mead\x04meat\x07\
pickaxe\x03pig\x0bfishing-rod\x03saw\x06scythe\x05sheep\x06shovel\x05stone\x06su\
lfur\x05sword\x07tequila\x05water\x04wine\x11backpack-catapult\x05goose\x0fexplo\
sive-arrow\x0dsunflower-oil\x09sunflower\x04\0\x09ware-kind\x03\0\0\x01r\x02\x04\
size}\x04kind\x01\x04\0\x0aware-stack\x03\0\x02\x01mB\x07carrier\x06planer\x07bu\
ilder\x0awoodcutter\x0bstonecutter\x08forester\x0cgrain-farmer\x0danimal-farmer\x06\
fisher\x0bwaterworker\x06hunter\x0esawmill-worker\x07smelter\x0amineworker\x05sm\
ith\x06miller\x05baker\x07butcher\x0fshipyard-worker\x06healer\x0echarcoal-maker\
\x0aammo-maker\x0dvehicle-maker\x06vinter\x09beekeeper\x09meadmaker\x0cagave-far\
mer\x0dtequila-maker\x10level1-swordsman\x10level2-swordsman\x10level3-swordsman\
\x0dlevel1-archer\x0dlevel2-archer\x0dlevel3-archer\x0clevel1-medic\x0clevel2-me\
dic\x0clevel3-medic\x12level1-axe-warrior\x12level2-axe-warrior\x12level3-axe-wa\
rrior\x0elevel1-blowgun\x0elevel2-blowgun\x0elevel3-blowgun\x0csquad-leader\x06p\
riest\x08saboteur\x07pioneer\x05thief\x09geologist\x08gardener\x0alandscaper\x0d\
dark-gardener\x0fmushroom-farmer\x06shaman\x0cdark-settler\x0etemple-servant\x0c\
level1-angel\x0clevel2-angel\x0clevel3-angel\x06donkey\x1blevel1-backpack-catapu\
ltist\x1blevel2-backpack-catapultist\x1blevel3-backpack-catapultist\x10sunflower\
-farmer\x0csunoil-maker\x11manacopter-master\x04\0\x0csettler-kind\x03\0\x04\x01\
o\x02{{\x01r\x03\x08position\x06\x04kind\x05\x07team-id}\x04\0\x07settler\x03\0\x07\
\x01m\x02\x05human\x08computer\x04\0\x0bplayer-kind\x03\0\x09\x01k\x0a\x01r\x02\x07\
team-id}\x04kind\x0b\x04\0\x0bteam-player\x03\0\x0c\x01mR\x0fwoodcutters-hut\x0d\
foresters-hut\x07sawmill\x10stonecutters-hut\x10waterworkers-hut\x0bfishers-hut\x0b\
hunters-hut\x0eslaughterhouse\x0agrain-mill\x06bakery\x0agrain-farm\x0bsheep-ran\
ch\x0cdonkey-ranch\x0astone-mine\x09iron-mine\x09gold-mine\x09coal-mine\x0bsulfu\
r-mine\x13gold-smelting-works\x13iron-smelting-works\x10toolsmiths-works\x12weap\
onsmiths-works\x0cvehicle-hall\x08barracks\x0echarcoal-maker\x0ftraining-center\x10\
healers-quarters\x11ammo-makers-works\x14gunpowder-makers-hut\x14landscape-maker\
s-hut\x08shipyard\x06harbor\x0bmarketplace\x0cstorage-area\x08vineyard\x11agave-\
farmers-hut\x12tequila-makers-hut\x0ebeekeepers-hut\x0emeadmakers-hut\x0fsmall-r\
esidence\x10medium-residence\x0flarge-residence\x0csmall-temple\x0clarge-temple\x0d\
lookout-tower\x0bsmall-tower\x0blarge-tower\x06castle\x12dark-mushroom-farm\x0bd\
ark-temple\x0ddark-fortress\x08harbor-a\x08harbor-b\x08harbor-c\x08harbor-d\x08h\
arbor-e\x08harbor-f\x0ashipyard-a\x0ashipyard-b\x0ashipyard-c\x0ashipyard-d\x0as\
hipyard-e\x0ashipyard-f\x04bust\x08monument\x08standart\x07obelisk\x05bench\x0ea\
rched-gateway\x0cflower-kind1\x09tombstone\x0cstone-plaque\x04vase\x06knight\x0c\
flower-kind2\x0ashipyard-g\x0ashipyard-h\x08harbor-g\x08harbor-h\x0fmanacopter-h\
all\x18sunflower-oil-makers-hut\x0esunflower-farm\x04\0\x0dbuilding-kind\x03\0\x0e\
\x01r\x0a\x08position\x06\x04kind\x0f\x07team-id}\x0bis-occupied\x7f\x10level1-s\
wordsmen}\x10level2-swordsmen}\x10level3-swordsmen}\x0elevel1-archers}\x0elevel2\
-archers}\x0elevel3-archers}\x04\0\x08building\x03\0\x10\x01m\x03\x06versus\x06s\
ingle\x04coop\x04\0\x08gamemode\x03\0\x12\x01m\x03\x03low\x06medium\x04high\x04\0\
\x11resource-richness\x03\0\x14\x01m\x05\x05roman\x05mayan\x06viking\x04dark\x06\
trojan\x04\0\x05tribe\x03\0\x16\x01n\x01\x07unknown\x04\0\x0bground-meta\x03\0\x18\
\x01m$\x0cwater-level1\x0cwater-level2\x0cwater-level3\x0cwater-level4\x0cwater-\
level5\x0cwater-level6\x0cwater-level7\x0cwater-level8\x0bwater-beach\x05grass\x0e\
grass-mountain\x0cgrass-island\x0cgrass-desert\x0bgrass-swamp\x09grass-mud\x0agr\
ass-dark\x0bgrass-weird\x0bgrass-dusty\x0egrass-pavement\x08mountain\x0emountain\
-grass\x0dmountain-snow\x05beach\x06desert\x0cdesert-grass\x05swamp\x0bswamp-gra\
ss\x0criver-width1\x0criver-width2\x0criver-width3\x0criver-width4\x04snow\x0dsn\
ow-mountain\x03mud\x09mud-grass\x08glitched\x04\0\x0bground-kind\x03\0\x1a\x01r\x03\
\x09elevation}\x04kind\x1b\x04meta\x19\x04\0\x06ground\x03\0\x1c\x01k\x15\x01r\x04\
\x08gamemode\x13\x0cplayer-limit}\x11resource-richness\x1e\x08map-sizey\x04\0\x04\
info\x03\0\x1f\x01k\x17\x01r\x03\x08position\x06\x05tribe!\x04names\x04\0\x06pla\
yer\x03\0\"\x01p\x0d\x01r\x02\x04names\x07players$\x04\0\x04team\x03\0%\x01p\x7f\
\x01k'\x01p\x11\x01k)\x01o\x02\x7f\x06\x01p+\x01k,\x01p{\x01k.\x01o\x02{\x01\x01\
p0\x01k1\x01r\x05\x11players-to-defeat(\x14buildings-to-destroy*\x0fground-to-cl\
aim-\x12seconds-to-survive/\x13resources-to-gather2\x04\0\x12victory-conditions\x03\
\03\x01p}\x01p\x08\x01p\x03\x01p\x1d\x01r\x09\x06nature5\x08settlers6\x09buildin\
gs)\x05wares7\x12victory-conditions4\x13mission-descriptions\x0cmission-hints\x0a\
lua-scripts\x09landscape8\x04\0\x03map\x03\09\x01j\x01:\x01s\x01@\x01\x04paths\0\
;\x04\0\x08load-map\x01<\x01j\x01\x20\x01s\x01@\x01\x04paths\0=\x04\0\x0dload-ma\
p-info\x01>\x04\0\x13s4:files/load@0.1.0\x05\x02\x04\0\x14s4:files/files@0.1.0\x04\
\0\x0b\x0b\x01\0\x05files\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit\
-component\x070.220.0\x10wit-bindgen-rust\x060.36.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
